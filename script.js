
	let records = [];





// This function just updates the Data Last Refreshed date
function updateLastRefreshed() {
    fetch('qualys-cve-epss-data.csv')
        .then(response => response.text())
        .then(data => {
            const rows = data.split('\n');
            if (rows.length > 1) {
                const secondRowColumns = rows[1].split(',');
                const lastRefreshed = secondRowColumns[12];
                if (lastRefreshed) {
                    document.getElementById('lastRefreshedDisplay').textContent = "Source data Last Refreshed: " + lastRefreshed;
                } else {
                    console.log("No 'Last Refreshed' date found");
                }
            }
        })
        .catch(error => {
            console.error("There was an error fetching the CSV:", error);
        });
}










// Fetch the CSV data when the document loads
document.addEventListener('DOMContentLoaded', function() {
    fetch('qualys-cve-epss-data.csv')
        .then(response => response.text())
        .then(data => {
            const csvRows = data.split('\n');
            const headers = parseCSVRow(csvRows[0]);
            
            for(let i = 1; i < csvRows.length; i++) {
                const rowArray = parseCSVRow(csvRows[i]);
                let rowObject = {};
                for(let j = 0; j < headers.length; j++) {
                    rowObject[headers[j]] = rowArray[j];
                }
                records.push(rowObject);
            }
            
            console.log("Records loaded:", records);
			updateLastRefreshed();

        }); 
});



function parseCSVRow(row) {
    let cells = [];
    let inQuotes = false;
    let currentValue = '';

    for (let i = 0; i < row.length; i++) {
        const char = row[i];
        if (inQuotes) {
            if (char === '"' && row[i + 1] === '"') {  // Double quotes are treated as a single quote in CSV
                currentValue += '"';
                i++;  // Skip next quote
            } else if (char === '"') {  // End of quoted value
                inQuotes = false;
            } else {
                currentValue += char;
            }
        } else {
            if (char === '"') {
                inQuotes = true;
            } else if (char === ',') {
                cells.push(currentValue);
                currentValue = '';
            } else {
                currentValue += char;
            }
        }
    }

    cells.push(currentValue);  // Add the last value
    return cells;
}



function searchByQID() {
    let qid = document.getElementById('qidSearch').value;
    console.log("Searching for QID:", qid);

    let matchedRecords = [];

    for(let record of records) {
        if (record["QID"] == qid) {
            matchedRecords.push(record);
        }
    }

    // Sort by CVE ID
    matchedRecords.sort((a, b) => {
        if (a["CVE"] < b["CVE"]) return -1;
        if (a["CVE"] > b["CVE"]) return 1;
        return 0;
    });

    // Clear previous results
    const tbody = document.getElementById('qid-result-tbody');
    tbody.innerHTML = "";

    if (matchedRecords.length) {
        for(let matchedRecord of matchedRecords) {
            let row = tbody.insertRow();

            // QID cell
            let cell = row.insertCell();
            cell.innerText = matchedRecord["QID"];

            // Title cell
            cell = row.insertCell();
            cell.innerText = matchedRecord["Qualys Vulnerability Title"];

            // QVS cell
            cell = row.insertCell();
            cell.innerText = matchedRecord["QVS"] || "";  // Assuming the record might have a "QVS" field, and default to ""

            // Associated CVEs cell
            cell = row.insertCell();
            cell.innerText = matchedRecord["CVE"];

            // EPSS Score cell
            cell = row.insertCell();
            cell.innerText = matchedRecord["EPSS"] || "";  // Display the EPSS associated with the specific CVE

            // CVSS baseScore cell
            cell = row.insertCell();
            cell.innerText = matchedRecord["CVSS baseScore"];

            // CVSS Version cell
            cell = row.insertCell();
            cell.innerText = matchedRecord["CVSS Version"];

            // CISA KEV
            cell = row.insertCell();
            cell.innerText = matchedRecord["CISA KEV"] || "";
			console.log(matchedRecord);
        }
		
        document.getElementById('qid-result').style.display = 'block';
    } else {
        tbody.innerHTML = "<tr><td colspan='7'>No results found for QID: " + qid + "</td></tr>";
    }
			// Clear the search input
			document.getElementById('qidSearch').value = '';
			document.getElementById('cveSearch').value = '';
			document.getElementById('cve-result').style.display = 'none';
}


function searchByCVE() {
    let cve = document.getElementById('cveSearch').value;

    // Ensure "CVE-" prefix is present
    if (!cve.startsWith("CVE-")) {
        cve = "CVE-" + cve;
    }
    
    // Filter matching records for the given CVE
    let matchedRecords = records.filter(record => record["CVE"] == cve);

    // Clear previous results
    const tbody = document.getElementById('cve-result-tbody');
    tbody.innerHTML = "";

    if (matchedRecords.length) {
        populateCVEtable(matchedRecords, tbody);
    } else {
        tbody.innerHTML = "<tr><td colspan='7'>No results found for CVE: " + cve + "</td></tr>";
    }

    document.getElementById('cve-result').style.display = 'block';
    document.getElementById('qidSearch').value = '';
    document.getElementById('cveSearch').value = '';
    document.getElementById('qid-result').style.display = 'none';
}

function populateCVEtable(records, tbody) {
    records.forEach(record => {
        let row = tbody.insertRow();

        // CVE cell
        let cell = row.insertCell();
        cell.innerText = record["CVE"];

        // QID cell
        cell = row.insertCell();
        cell.innerText = record["QID"];

        // Title cell
        cell = row.insertCell();
        cell.innerText = record["Qualys Vulnerability Title"];

        // QVS cell
        cell = row.insertCell();
        cell.innerText = record["QVS"] || "";

        // EPSS cell
        cell = row.insertCell();
        cell.innerText = record["EPSS"] || "";

        // CVSS Base cell
        cell = row.insertCell();
        cell.innerText = record["CVSS baseScore"];

        // CVSS3.1 Base cell
        cell = row.insertCell();
        cell.innerText = record["CVSS Version"];

		// CISA KEV
		cell = row.insertCell();
		cell.innerText = record["CISA KEV"] || "";
    });
}

let currentSort = {
    column: null,
    asc: true
};

document.getElementById("header-qid").addEventListener('click', () => sortBy('QID'));
document.getElementById("header-title").addEventListener('click', () => sortBy('Qualys Vulnerability Title'));
document.getElementById("header-qvs").addEventListener('click', () => sortBy('QVS', true));
document.getElementById("header-epss").addEventListener('click', () => sortBy('EPSS', true));
document.getElementById("header-cve").addEventListener('click', () => sortBy('CVE'));
document.getElementById("header-cvss").addEventListener('click', () => sortBy('CVSS baseScore', true));
document.getElementById("header-cvss3").addEventListener('click', () => sortBy('CVSS Version', true));
document.getElementById("header-cisakev").addEventListener('click', () => sortBy('CISA KEV'));

function sortBy(column, isNumeric=false) {
    const tbody = document.getElementById('qid-result-tbody');
    const rows = Array.from(tbody.rows);

    // If the column is the same as the last sorted column, toggle the sort direction
    // Otherwise, reset the sort direction to ascending
    if (currentSort.column === column) {
        currentSort.asc = !currentSort.asc;
    } else {
        currentSort.column = column;
        currentSort.asc = true; // Default to ascending for a new column
    }

    rows.sort((a, b) => {
        let valA = a.cells[columnHeaders[column]].innerText;
        let valB = b.cells[columnHeaders[column]].innerText;

        if (isNumeric) {
            valA = parseFloat(valA);
            valB = parseFloat(valB);
        }

        return currentSort.asc ? compare(valA, valB) : compare(valB, valA);
    });

    // Re-append rows to tbody
    rows.forEach(row => tbody.appendChild(row));
}

function compare(a, b) {
    if (a < b) return -1;
    if (a > b) return 1;
    return 0;
}



const columnHeaders = {
    'QID': 0,
    'Qualys Vulnerability Title': 1,
    'QVS': 2,
    'CVE': 3,
    'EPSS': 4,
    'CVSS baseScore': 5,
    'CVSS Version': 6,
    'CISA KEV': 7
};

